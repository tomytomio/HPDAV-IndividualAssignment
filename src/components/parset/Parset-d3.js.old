import * as d3 from 'd3';

class ParsetD3 {
    margin = {top: 20, right: 20, bottom: 20, left: 20};
    constructor(el){
        this.el = el;
        this.svg = null;
        this.width = 800;
        this.height = 400;  // increased height for better visibility
        this.axisGap = 180; // horizontal gap between axes
        this.axisBoxWidth = 120; // width reserved per axis
        this.valueHeight = 16; // height per category item
    }

    clear(){
        d3.select(this.el).selectAll("*").remove();
    }

    create(config){
        this.size = {width: config.size.width || this.width, height: config.size.height || this.height};
        this.width = this.size.width - this.margin.left - this.margin.right;
        this.height = this.size.height - this.margin.top - this.margin.bottom;

        this.svg = d3.select(this.el).append('svg')
            .attr('width', this.width + this.margin.left + this.margin.right)
            .attr('height', this.height + this.margin.top + this.margin.bottom)
            .append('g')
            .attr('transform', `translate(${this.margin.left},${this.margin.top})`)
            .attr('class','parset-g');
    }

    // Build internal structures: axes positions, category bins and flows with path memory
    computeLayout(data, axes){
        // axes: array of attribute keys in order
        const nodes = {};
        const total = data.length;

        // For each axis compute categories and counts, considering all previous axes
        axes.forEach((attr, axisIndex) => {
            const map = new Map();
            
            data.forEach(d => {
                // Build cumulative path key including all previous attributes
                const pathKeys = [];
                for(let i = 0; i <= axisIndex; i++) {
                    let v = d[axes[i]];
                    if (v === true || v === false) v = v ? 'true' : 'false';
                    else if (v === null || v === undefined || v === '') v = 'NA';
                    else v = String(v);
                    pathKeys.push(v);
                }
                const pathKey = pathKeys.join('::');
                
                if (!map.has(pathKey)) {
                    map.set(pathKey, {
                        key: pathKey,
                        value: pathKeys[pathKeys.length - 1], // current attribute value
                        path: pathKeys.slice(0, -1), // previous values
                        count: 0,
                        items: []
                    });
                }
                const entry = map.get(pathKey);
                entry.count += 1;
                entry.items.push(d.index);
            });
            
            // Group cats by current value for display
            const valueMap = new Map();
            map.forEach(entry => {
                const val = entry.value;
                if (!valueMap.has(val)) {
                    valueMap.set(val, {
                        key: val,
                        count: 0,
                        items: [],
                        paths: new Map()
                    });
                }
                const vEntry = valueMap.get(val);
                vEntry.count += entry.count;
                vEntry.items.push(...entry.items);
                vEntry.paths.set(entry.path.join('::'), {
                    count: entry.count,
                    items: entry.items
                });
            });
            
            const cats = Array.from(valueMap.values())
                .sort((a,b) => b.count - a.count);
            nodes[attr] = {attr, cats, pathMap: map};
        });

        // Compute flows between adjacent axes
        const links = [];
        for(let i=0; i<axes.length-1; i++){
            const a1 = axes[i];
            const a2 = axes[i+1];
            const m = new Map();
            
            // Use the pathMap to create flows
            const node2 = nodes[a2];
            node2.pathMap.forEach((entry, pathKey) => {
                const path = entry.path;
                const sourcePath = path.join('::');
                const targetPath = pathKey;
                
                if (!m.has(sourcePath + "::" + targetPath)) {
                    m.set(sourcePath + "::" + targetPath, {
                        source: path[path.length - 1] || entry.value,
                        target: entry.value,
                        sourcePath: path,
                        targetPath: entry.path.concat([entry.value]),
                        count: 0,
                        items: []
                    });
                }
                const e = m.get(sourcePath + "::" + targetPath);
                e.count = entry.count;
                e.items = entry.items;
            });
            
            links.push({
                sourceAttr: a1,
                targetAttr: a2,
                links: Array.from(m.values())
            });
        }

        return {nodes, links, total};
    }

    render(data, axes, state){
        // state: {selected: {attr: Set(values)}, order: {attr: [values...]}}
        if (!this.svg) return;
        const layout = this.computeLayout(data, axes);

        // compute x positions for axes based on axes order
        const axisCount = axes.length;
        const gap = (axisCount>1) ? ((this.width - 40)/(axisCount-1)) : this.width/2;
        const x = (i) => i*gap;
        const rectW = 6; // slim vertical line for categories        // scale for stacking categories vertically within each axis
        // draw axis groups
        const axisG = this.svg.selectAll('.axisG')
            .data(axes, d=>d)
            .join(enter=>enter.append('g').attr('class','axisG'))
            .attr('transform', (d,i) => `translate(${x(i)},0)`);

        // Axis title
        axisG.selectAll('text.axisTitle')
            .data(d=>[d])
            .join('text')
            .attr('class','axisTitle')
            .attr('x',0)
            .attr('y',-6)
            .text(d=>d);

        // For each axis create category groups
        axisG.each((attr, i, nodes) => {
            const node = layout.nodes[attr];
            if (!node) return;
            // order of values: either state.order[attr] or node.cats.map(k=>k.key)
            const orderArr = (state.order && state.order[attr]) ? state.order[attr] : node.cats.map(c=>c.key);
            // build a map to get counts quickly
            const catMap = new Map(node.cats.map(c=>[c.key,c]));
            const total = node.cats.reduce((s,c)=>s+c.count,0);

            const yScale = d3.scaleLinear().domain([0,total]).range([0,this.height]);

            // compute positions
            let yPos=0;
            const records = orderArr.map(k=>{
                const c = catMap.get(k) || {key:k,count:0,items:[]};
                const h = yScale(c.count);
                const obj = {key:c.key, count:c.count, y:yPos, h:Math.max(2,h)};
                yPos += obj.h + 4; // gap
                return obj;
            });

            // bind
            const g = d3.select(nodes[i]);
            const vals = g.selectAll('.cat')
                .data(records, d=>d.key)
                .join(enter=>{
                    const eg = enter.append('g').attr('class','cat');
                    eg.append('rect').attr('class','catRect')
                    eg.append('text').attr('class','catLabel')
                    return eg;
                }, update=>update, exit=>exit.remove());

            vals.attr('transform', d=>`translate(0,${d.y})`)
                .select('rect.catRect')
                .attr('width', rectW)
                .attr('height', d=>d.h)
                .attr('fill', d=> state.selected && state.selected[attr] && state.selected[attr].has(d.key) ? '#ff7f0e' : '#69b3a2')
                .attr('stroke','none')
                .attr('opacity', d=> d.count===0?0.2:1);

            vals.select('text.catLabel')
                .attr('x', rectW + 4)
                .attr('y', d=>Math.max(10, d.h/2+4))
                .text(d=>`${d.key} (${d.count})`)
                .style('font-size','12px')
                .style('pointer-events', 'none'); // prevent text from interfering with drag

            // behavior: click toggles selection
            vals.on('click', (event,d)=>{
                if (!state.onToggle) return;
                state.onToggle(attr,d.key);
            });

            // vertical drag to reorder values inside axis with precise positioning
            const drag = d3.drag()
                .on('start', (event,d)=>{ 
                    d._startY = event.y;
                    d._origY = d.y;
                    d._origOrder = orderArr.slice();
                })
                .on('drag', (event,d)=>{
                    d._dy = event.y - d._startY;
                    
                    // Create or update drag ghost instead of moving original
                    let ghost = g.select('.dragGhost');
                    if (ghost.empty()) {
                        ghost = g.append('g')
                            .attr('class', 'dragGhost')
                            .style('opacity', 0.6);
                        
                        ghost.append('rect')
                            .attr('width', rectW)
                            .attr('height', d.h)
                            .attr('fill', '#ff7f0e');
                            
                        ghost.append('text')
                            .attr('x', rectW + 4)
                            .attr('y', d.h/2 + 4)
                            .text(`${d.key} (${d.count})`)
                            .style('font-size', '12px');
                    }
                    ghost.attr('transform', `translate(0,${d._origY + d._dy})`);
                    
                    // show drop indicator
                    const dragY = d._origY + d._dy;
                    g.selectAll('.dropIndicator').remove();
                    g.append('line')
                        .attr('class', 'dropIndicator')
                        .attr('x1', -4)
                        .attr('x2', rectW + 100) // extend past label
                        .attr('y1', dragY)
                        .attr('y2', dragY)
                        .attr('stroke', '#ff7f0e')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '4,4');
                })
                .on('end', (event,d)=>{
                    if (!state.onReorder) return;
                    g.selectAll('.dropIndicator, .dragGhost').remove();
                    
                    // find closest category position and insert there
                    const dragY = d._origY + (d._dy||0);
                    const positions = records.map(r => ({key: r.key, y: r.y}))
                        .sort((a,b) => a.y - b.y);
                    
                    // find insertion point
                    let insertIdx = 0;
                    for(let i=0; i<positions.length; i++) {
                        if (dragY > positions[i].y) insertIdx = i + 1;
                    }
                    
                    // compute new order
                    const newOrder = d._origOrder.filter(k => k !== d.key);
                    newOrder.splice(insertIdx, 0, d.key);
                    
                    state.onReorder(attr, newOrder);
                });

            vals.call(drag);
        });

        // draw links (ribbons) between adjacent axes
        // flatten link segments and draw curved areas with low opacity
    // scale stroke width by counts relative to total
    const strokeScale = d3.scaleSqrt().domain([0, Math.max(1, layout.total)]).range([0.5, 6]);

    const linkG = this.svg.selectAll('.linkG').data(layout.links).join(enter=>enter.append('g').attr('class','linkG'));

        linkG.each((linkObj, idx, nodes) => {
            const g = d3.select(nodes[idx]);
            const a1 = linkObj.sourceAttr, a2 = linkObj.targetAttr;
            const node1 = layout.nodes[a1];
            const node2 = layout.nodes[a2];
            const order1 = (state.order&&state.order[a1])?state.order[a1]:node1.cats.map(c=>c.key);
            const order2 = (state.order&&state.order[a2])?state.order[a2]:node2.cats.map(c=>c.key);

            // build map of y positions
            const buildPositions = (node, order)=>{
                const catMap = new Map(node.cats.map(c=>[c.key,c]));
                const total = node.cats.reduce((s,c)=>s+c.count,0);
                const yScale = d3.scaleLinear().domain([0,total]).range([0,this.height]);
                let yPos = 0;
                const pos = new Map();
                order.forEach(k=>{
                    const c = catMap.get(k) || {key:k,count:0};
                    const h = Math.max(2,yScale(c.count));
                    pos.set(k,{y:yPos,h});
                    yPos += h + 4;
                });
                return pos;
            }

            const pos1 = buildPositions(node1, order1);
            const pos2 = buildPositions(node2, order2);

            // Sort links by count (ascending) to stack smaller flows on top
            // Filter and prepare links
            const activeLinks = linkObj.links.filter(l => l.count > 0);
            console.log("Active links:", activeLinks);

            // Group by source and target
            const sourceGroups = new Map();
            const targetGroups = new Map();
            
            activeLinks.forEach(l => {
                const sourceKey = l.source;
                const targetKey = l.target;
                
                if (!sourceGroups.has(sourceKey)) sourceGroups.set(sourceKey, []);
                if (!targetGroups.has(targetKey)) targetGroups.set(targetKey, []);
                sourceGroups.get(sourceKey).push(l);
                targetGroups.get(targetKey).push(l);
            });

            console.log("Source groups:", Array.from(sourceGroups.entries()));
            console.log("Target groups:", Array.from(targetGroups.entries()));

            // Sort links within each group by count
            for (let group of sourceGroups.values()) {
                group.sort((a, b) => b.count - a.count);
            }
            for (let group of targetGroups.values()) {
                group.sort((a, b) => b.count - a.count);
            }

            // Calculate positions within each source/target
            const sourcePositions = new Map();
            const targetPositions = new Map();
            
            // Calculate positions within each source/target group
            sourceGroups.forEach((links, sourceValue) => {
                const sourceCat = node1.cats.find(c => c.key === sourceValue);
                if (!sourceCat) return;
                
                let cumPos = 0;
                links.sort((a, b) => b.count - a.count);
                
                links.forEach(l => {
                    const key = `${l.source}->${l.target}`;
                    sourcePositions.set(key, cumPos / sourceCat.count);
                    cumPos += l.count;
                });
            });
            
            targetGroups.forEach((links, targetValue) => {
                const targetCat = node2.cats.find(c => c.key === targetValue);
                if (!targetCat) return;
                
                let cumPos = 0;
                links.sort((a, b) => b.count - a.count);
                
                links.forEach(l => {
                    const key = `${l.source}->${l.target}`;
                    targetPositions.set(key, cumPos / targetCat.count);
                    cumPos += l.count;
                });
            });

            console.log("Source positions:", Array.from(sourcePositions.entries()));
            console.log("Target positions:", Array.from(targetPositions.entries()));

            const segs = linkObj.links.filter(l => l.count > 0);

            // compute indices matching current selection (intersection across attrs)
            let matchingIndices = null;
            if (state.selected && Object.keys(state.selected).length>0){
                // map data index -> row using provided data array
                const indexToRow = new Map(data.map(r=>[r.index, r]));
                // start with full set
                matchingIndices = new Set(indexToRow.keys());
                for(const [sattr, sset] of Object.entries(state.selected)){
                    if (!sset || sset.size===0) continue;
                    const thisSet = new Set();
                    for(const [i,row] of indexToRow.entries()){
                        let v = row[sattr];
                        if (v===true||v===false) v = v? 'true':'false'; else v = (v==null||v==='')? 'NA': String(v);
                        if (sset.has(v)) thisSet.add(i);
                    }
                    // intersect
                    matchingIndices = new Set([...matchingIndices].filter(x=>thisSet.has(x)));
                }
            }

            // prepare paths
            const paths = g.selectAll('path.link').data(segs, d=>d.source+"->"+d.target)
                .join(enter=>enter.append('path').attr('class','link'));

            paths.attr('d', d=>{
                const p1 = pos1.get(d.source) || {y:0,h:2};
                const p2 = pos2.get(d.target) || {y:0,h:2};
                const x1 = x(axes.indexOf(a1)) + rectW; // right edge of axis box
                const x2 = x(axes.indexOf(a2));
                
                // Get source and target category totals
                const sourceTotal = node1.cats.find(c => c.key === d.source)?.count || 0;
                const targetTotal = node2.cats.find(c => c.key === d.target)?.count || 0;
                
                // Use simple source->target key
                const key = `${d.source}->${d.target}`;
                const yStart = sourcePositions.get(key) || 0;
                const yEnd = targetPositions.get(key) || 0;
                
                // Get source and target categories
                const sourceCat = node1.cats.find(c => c.key === d.source);
                const targetCat = node2.cats.find(c => c.key === d.target);
                
                if (!sourceCat || !targetCat) {
                    console.warn('Missing category:', {source: d.source, target: d.target});
                    return 'M0,0Z'; // return empty path
                }

                // Calculate heights and positions
                const h1 = Math.max(1, p1.h * (d.count / sourceCat.count));
                const h2 = Math.max(1, p2.h * (d.count / targetCat.count));
                
                // Get positions from maps using simple key
                const key = `${d.source}->${d.target}`;
                const y1 = p1.y + (sourceCat.h * (sourcePositions.get(key) || 0));
                const y2 = p2.y + (targetCat.h * (targetPositions.get(key) || 0));

                console.log('Ribbon calc:', {
                    source: d.source,
                    target: d.target,
                    count: d.count,
                    y1, y2, h1, h2
                });
                
                // Ensure we don't exceed category bounds
                const y1End = Math.min(p1.y + p1.h, y1 + h1);
                const y2End = Math.min(p2.y + p2.h, y2 + h2);
                
                const mid = (x1 + x2)/2;
                
                // draw filled area using cubic bezier curves for top and bottom
                return `M${x1},${y1}
                        C${mid},${y1} ${mid},${y2} ${x2},${y2}
                        L${x2},${y2End}
                        C${mid},${y2End} ${mid},${y1End} ${x1},${y1End}
                        Z`;
            })
            .attr('fill', d=>{
                if (!matchingIndices || matchingIndices.size===0) return '#999';
                const match = d.items.some(i=> matchingIndices.has(i));
                return match ? '#ff7f0e' : '#999';
            })
            .attr('stroke', 'none')
            .attr('opacity', d=>{
                if (!matchingIndices) return 0.3;
                const match = d.items.some(i=> matchingIndices.has(i));
                return match ? 0.7 : 0.05;
            });

        });
    }
}

export default ParsetD3;
